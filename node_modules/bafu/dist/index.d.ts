export declare function compose<T extends Fn[]>(...fns: [...T] extends ComposedFns<[...T]> ? [...T] : never): (...args: Parameters<LastT<T>>) => ReturnType<T[0]>;
export declare function pipe<T extends Fn, U extends Fn[]>(fn1: T, ...fns: U extends Shift<PipeFns<[T, ...U]>> ? U : never): (...args: Parameters<T>) => ReturnType<LastT<U, any>>;
export declare function queue<T extends Fn[]>(...fns: T): (...args: any) => ReturnType<LastT<T, any>>;
export declare function curry<T extends Fn, U extends any[]>(f: T, ...args: U extends Partial<Parameters<T>> ? U : never): (...args2: RemainingTuple<U, Parameters<T>>) => ReturnType<T>;
export declare function aim<T extends Fn, U extends any[]>(f: T, ...args2: U extends IsAimArgs<U, Parameters<T>> ? U : never): (...args_0: AimArgs<U, Parameters<T>, [], never>) => ReturnType<T>;
export declare function some<T extends Fn[]>(...fns: [...T]): (...args: Parameters<T[0]>) => boolean;
export declare function every<T extends Fn[]>(...fns: [...T]): (...args: Parameters<T[0]>) => boolean;
export declare function map<T extends Fn[]>(...fns: HasSuperParams<T>): (...args: FindSuperParams<T>) => GetRetTypes<T, []>;
export declare function flatMap<T extends Fn[]>(...fns: HasSParamsAndRets<T>): (...args: FindSuperParams<T>) => GetRetTypes<T, []>[0];
export declare function guard<T extends Fn, U extends (arg: GuardType<T>) => any>(f: U, gfn: T): (arg: Parameters<T>[0]) => ReturnType<U> | null;
export declare function ifSome<T extends Fn>(mainFn: T, ...checks: ((...args: Parameters<T>) => boolean)[]): (...args_0: Parameters<T>) => ReturnType<T> | null;
export declare function ifEvery<T extends Fn>(mainFn: T, ...checks: ((...args: Parameters<T>) => boolean)[]): (...args_0: Parameters<T>) => ReturnType<T> | null;
declare type Fn = (...args: any[]) => any;
declare type LastT<T extends any[], R = any> = T extends [infer a, ...infer tRest] ? LastT<tRest, a> : R;
declare type ComposedFns<T extends any[]> = T extends [
    (...args: infer p) => any,
    (...args: any[]) => infer t,
    ...infer rest
] ? t extends p[0] ? Shift<p> extends [] ? [T[0], ...ComposedFns<Shift<T>>] : never : never : T;
declare type Shift<T extends any[]> = Eq<T, []> extends true ? [] : T extends [(infer t)?, ...infer tRest] ? tRest : [];
declare type PipeFns<T extends any[]> = T extends [
    (...args: any[]) => infer t,
    (...args: infer p) => any,
    ...infer rest
] ? t extends p[0] ? Shift<p> extends [] ? [T[0], ...PipeFns<Shift<T>>] : never : never : T;
declare type Eq<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false;
declare type IsSuperset<T1, T2> = T1 extends [infer t1, ...infer t1Rest] ? T2 extends [infer t2, ...infer t2Rest] ? Eq<t1, t2> extends true ? IsSuperset<t1Rest, t2Rest> : false : true : [T2] extends [never] ? false : T2 extends [] ? true : false;
declare type HasSParamsAndRets<T extends Fn[]> = FindSuperParams<T> extends never ? never : IsSameRets<T> extends never ? never : [...T];
declare type HasSuperParams<T extends Fn[]> = FindSuperParams<T> extends never ? never : [...T];
declare type IsSameRets<T extends Fn[]> = IsSameTypes<GetRetTypes<T>>;
declare type FindSuperParams<T extends Fn[]> = FindSuperset<GetFnsParams<T>>;
declare type IsSameTypes<T extends any[]> = T extends [infer a, infer b, ...infer rest] ? Eq<a, b> extends true ? IsSameTypes<[b, ...rest]> : never : [...T];
declare type FindSuperset<T extends any[], S extends any = []> = T extends [
    infer a,
    infer b,
    ...infer rest
] ? IsSuperset<a, b> extends true ? FindSuperset<[a, ...rest], a> : IsSuperset<b, a> extends true ? FindSuperset<[b, ...rest], b> : never : S;
declare type GetFnsParams<T extends any[], P extends any[] = []> = T extends [
    infer f,
    ...infer rest
] ? f extends Fn ? GetFnsParams<rest, [...P, Parameters<f>]> : never : P;
declare type GetRetTypes<T extends any[], R extends any[] = []> = T extends [
    infer a,
    ...infer rest
] ? a extends Fn ? GetRetTypes<rest, [...R, ReturnType<a>]> : never : R;
declare type RemainingTuple<Provided extends any[], Params extends any[]> = Provided extends [infer a, ...infer pRest] ? Params extends [(infer b)?, ...infer eRest] ? RemainingTuple<pRest, eRest> : never : Params;
declare type Is1stMatch<T extends any[], P extends any[]> = T extends [
    infer a,
    ...infer rest
] ? P extends [(infer b)?, ...infer pRest] ? Eq<a, b> extends true ? Is1stMatch<rest, pRest> : false : false : true;
declare type IsPartialMatch<T extends any[], P extends any[]> = P extends [] ? false : Is1stMatch<T, P> extends true ? true : IsPartialMatch<T, Shift<P>>;
declare type IsAimArgs<T extends any[], P extends any[]> = IsPartialMatch<T, P> extends true ? T : never;
declare type UnPartial1st<T extends any[]> = T extends [(infer a)?, ...infer r] ? a : never;
declare type AimArgs<T extends any[], P extends any[], Args extends any[] = [], Found = never> = P extends [] ? Found : Is1stMatch<T, P> extends true ? AimArgs<T, Shift<P>, [...Args, UnPartial1st<P>], Args> : AimArgs<T, Shift<P>, [...Args, UnPartial1st<P>], Found>;
declare type GuardType<TFunc> = TFunc extends (arg: any) => arg is infer R ? R : never;
export {};
